{
  "exerciseSheet": false,
  "blocks": [
    {
      "type": "text",
      "text": "# Tactics for Waterproof"
    },
    {
      "type": "code",
      "text": "Require Import Rbase.\nRequire Import Rfunctions.\nRequire Import SeqSeries.\nRequire Import Rtrigo.\nRequire Import Ranalysis.\nRequire Import Integration.\nRequire Import micromega.Lra.\nRequire Import Omega.\nRequire Import Max.\n(* Require Import Unicode.Utf8. *)\n\nRequire Import wplib.Notations.Notations."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "## **A powertool**\n\nTODO: in some cases, eauto has left some existentials.\nThis may be undesired, but eauto can be very powerful...\nOne option is to let waterproof check whether  existentials are created and block this behavior."
    },
    {
      "type": "code",
      "text": "Ltac wp_power :=\n  timeout 60 (first [ solve [auto with *]\n        | solve [eauto with *]\n        | solve [firstorder (auto with *)]\n        | solve [firstorder (eauto with *)]])."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "## **Introducing variables and hypotheses.**\n\nThe following tactics are variations on the `intro` tactic.\nWe distinguish on introducing variables (`Take`) and listing assumptions (`Assume`).\nCurrently supports introduction of one and two terms simultaneously.\n\n**TODO**:\n- Variable arity of tactics\n- More variation on choice of specific words (e.g. `Let` instead of `Take`; `and` instead of `','`)\n- Consider assumptions as sequence of conjunctions\n- Consider more fluent introduction of $\\varepsilon > 0$, $n \\geq N$, etc.\n- Add more feedback."
    },
    {
      "type": "text",
      "text": "#### **Strict introduction**\nMatch introduced variable / assumption exactly with its type."
    },
    {
      "type": "code",
      "text": "Ltac intro_strict s t :=\n  match goal with\n    | [ |- forall _ : t, _ ] => intro s\n  end.\n\nLtac assume_strict s t :=\n  match goal with\n    | [ |- ?u -> _ ] => (change u with t; intro s)\n  end.\n"
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "#### **Introducing variables**\nEnforce a strict introduction."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Take\" ident(s) \":\" constr(t):= \n  intro_strict s t.\n \nTactic Notation \"Take\" ident(s1) \",\" ident(s2) \":\" constr(t):=\n  intro_strict s1 t; intro_strict s2 t.\n   \nTactic Notation \"Take\" ident(s1) \":\" constr(t1) \",\" ident(s2) \":\" constr(t2) :=\n  intro_strict s1 t1; intro_strict s2 t2."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "#### **Assuming hypotheses**\nBoth strict and non-strict introduction.\nIf the goal contains a conjunction of hypothesis, split them into two separate hypotheses."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Assume\" ident(s) :=\n  intro s.\n \nTactic Notation \"Assume\" ident(s1) \"and\" ident(s2) :=\n  match goal with\n  | [ |- _ -> _ -> _ ] => intros s1 s2\n  | [ |- _ /\\ _ -> _ ] => intro s1; destruct s1 as [s1 s2]\n  end.\n\nTactic Notation \"Assume\" ident(s) \":\" constr(t) :=\n  assume_strict s t.\n\nTactic Notation \"Assume\" ident(s1) \":\" constr(t1) \"and\" ident(s2) \":\" constr(t2) :=\n  match goal with\n  | [ |- _ -> _ -> _ ] => assume_strict s1 t1; assume_strict s2 t2\n  | [ |- _ /\\ _ -> _ ] => idtac \"Not yet supported\"\n  end."
    },
    {
      "type": "text",
      "text": "#### **Introducing variable with assumption**\nTake care of introducing a variable with an assumption, e.g. let $\\varepsilon \\in \\mathbb{R}$ such that $ε > 0$.\\\n**TODO**: this should be implemented differently."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Take\" ident(s1) \":\" constr(t1) \"such\" \"that\" ident(s2) := \n  intro_strict s1 t1; intro s2."
    },
    {
      "type": "text",
      "text": "## **Checking the context**\n\nThe following tactics let the user record in the proof script various aspects of the current context.\nIn particular, users can state or manipulate the exact goal, and rename or add existing hypotheses.\\\n**TODO**\n- More precisely specify how much rephrasing is possible.\n- Add more feedback for when a tactic fails."
    },
    {
      "type": "text",
      "text": "#### **Checking the goal**\n\nMake it possible to verify the goal t by writing: `We need to show that t` or `To show: t`."
    },
    {
      "type": "code",
      "text": "Ltac goal_check t :=\n  tryif (change t) \n    then (idtac \"We indeed need to show that\" t)\n    else fail \"This is not the current goal\".\n\nTactic Notation \"We\" \"need\" \"to\" \"show\" \"that\" constr(t) :=\n  goal_check t.\n\nTactic Notation \"To\" \"show\" \":\" constr(t) :=\n  goal_check t.\n"
    },
    {
      "type": "text",
      "text": "#### **Checking hypotheses**\nThese tactics allow for renaming existing hypotheses.\nMoreover, it is now possible to add existing lemmas to the context."
    },
    {
      "type": "code",
      "text": "Ltac hypo_check s t:=\nmatch goal with \n| [H : t |- _] => rename H into s\n| _ => fail\nend.\n\nTactic Notation \"We\" \"know\" ident(s) \":\" constr(t) :=\n  hypo_check s t.\n\nTactic Notation \"By\" constr(t) \"we\" \"know\" ident(s) :=\n  pose proof t as s."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "## **Choosing variables that exist**\n\nThe following tactics are variations on two tactics that act on existential quantifiers; `exists` and `destruct`.\nWith the former, we want to express a specific choice, whereas the latter is often used when a hypothesis contains an $\\exists$.\\\n**TODO**\n- How flexible do we want these tactics?\n- Add a hypothesis check to ensure the hypothesis has the form `∃ _ : _, _`."
    },
    {
      "type": "text",
      "text": "#### **Exists in goal**\n\nChoose a specific value.\n(Should the order in the second tactic not be reversed?)"
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Choose\" constr(t):=\n  exists t.\n\nTactic Notation \"Choose\" ident(s) \":=\" constr(t) :=\n  pose (s := t);\n  exists s."
    },
    {
      "type": "text",
      "text": "#### **Exists in hypothesis**\n\nE.g. when the hypothesis reads ``∃ n : ℕ``, we can 'introduce' such an `n`."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Choose\" ident(s) \n                \"such\" \"that\" ident(u)\n                \"according\" \"to\" constr(v) (*\":\" constr(t)*):=\n  destruct v as [s u].\n\n(*Tactic Notation \"Choose\" ident(s)\n                \"such\" \"that\" ident(u)\n                \"according\" \"to\" ident(v)\n                \"with\" constr(t) :=\n  destruct v with t as [s u]. *)\n\nTactic Notation \"Choose\" ident(s)\n                \"such\" \"that\" ident(u)\n                \"according\" \"to\" constr(v)\n                \"with\" constr(t) :=\n  destruct v with t as [s u]."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "## **Forward reasoning**\n\nThese tactics try to use forward reasoning to deduce more useful hypothesis."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Because\" ident(s) \n  \"both\" ident(u) \"and\" ident(v) :=\n  destruct s as [u v].\n\nTactic Notation \"Because\" ident(s) \n  \"both\" ident(u) \":\" constr(t_u)\n  \"and\"  ident(v) \":\" constr(t_v):=\n  destruct s as [u v].\n\nTactic Notation \"Because\" ident(s)\n  \"either\" ident(u) \"or\" ident(v) :=\n  destruct s as [u | v]."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "## **Forward reasoning by automation**\nThe following tactics try to automatically reduce the goal by doing trivial substeps.\\\n**TODO**\n- Formalise the amount of automation\n- Uniform notation"
    },
    {
      "type": "code",
      "text": "(** Apply with goal check\n    The next tactics verify whether certain steps have the desired effect. *)\nLtac new_goal_verified_apply s t :=\n  apply s;\n  match goal with \n  | [|- t] => idtac \"Expected goal was produced\"\n  | _ => fail \"Lemma did not produce expected outcome\"\n  end.\n\n(*Tactic Notation \"By\" constr(s) \n  \"it\" \"suffices\" \"to\" \"show\" \"that\"\n  constr(t) :=\n  new_goal_verified_apply s t.*)\n\n(** A powerful forward reasoning tactic. \n    The sequential trying of auto and eauto \n    is there because eauto can be much slower. \n    TODO: is this what we want? *)\nLtac new_hyp_verified_pose_proof s t u:=\n  assert (u : t) by timeout 60 (first [ solve [auto using s with *]\n                          | solve [eauto using s with *]\n                          | solve [firstorder using s]\n                          | solve [firstorder (eauto with *) using s]\n                          | idtac \"Waterproof could not find a proof. If you believe the statement should hold, try making a smaller step\"]).\n\nLtac new_hyp_verified_pose_proof_no_name s t:=\n  assert t by timeout 60 (first [ solve [auto using s with *]\n                          | solve [eauto using s with *]\n                          | solve [firstorder using s]\n                          | solve [firstorder (eauto with *) using s]\n                          | idtac \"Waterproof could not find a proof. If you believe the statement should hold, try making a smaller step\"]).\n\nTactic Notation \"By\" constr(s)\n  \"it\" \"holds\" \"that\" constr(t) \"(\"ident(u)\")\"\n  := new_hyp_verified_pose_proof s t u.\n\nTactic Notation \"By\" constr(s)\n  \"it\" \"holds\" \"that\" constr(t)\n  := new_hyp_verified_pose_proof_no_name s t.\n\n(*Tactic Notation \"By\" constr(s0) \",\" constr(s1)\n  \"it\" \"holds\" \"that\" constr(t) \"(\"ident(u)\")\"\n  :=*)\n\n(* TODO: align syntax with \"By ... it holds that\" *)\nTactic Notation \"It\" \"holds\" \"that\"\n  constr(t) \"(\" ident(u) \")\" :=\n  assert (u : t) by first [ wp_power\n                          | idtac \"Waterproof could not find a proof. If you believe the statement should hold, try making a smaller step\"].\n\nLtac conclude_proof t :=\n  match goal with\n  | [|-t] => idtac\n  | _ => (idtac \"Warning: The statement you provided does not exactly correspond to the current goal. This can make your proof less readable.\"; change t || fail \"The provided statement cannot be converted to the current goal. If you are trying to prove an intermediate step, add a name to your hypothesis between brackets at the end of the sentence.\")\n  end; first [wp_power | fail \"Waterproof could not find a proof. Try making a smaller step.\"].\n\nTactic Notation \"It\" \"holds\" \"that\" constr(t) :=\n  conclude_proof t.\n\nTactic Notation \"It\" \"follows\" \"that\" constr(t) :=\n  conclude_proof t."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "TODO: preferably deprecate this notation."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"This\" \"follows\" \"immediately\" :=\n  wp_power.\n\nTactic Notation \"follows\" \"immediately\" := \n  wp_power."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"It\" \"suffices\" \"to\" \"show\" \"that\"\n  constr(t) :=\n  enough t by ( wp_power || fail \"Waterproof could not confirm that proving the statement would be enough.\")."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"It\" \"suffices\" \"to\" \"show\" \"that\"\n  constr(t) \"by\" tactic(tac) :=\n  enough t by tac."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Write\" \"goal\" \"using\" constr(t) \"as\" \n  constr(s) :=\n  let u := fresh in\n    assert (u : t) by wp_power;\n  rewrite u;\n  enough s by wp_power;\n  clear u."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Write\" ident(H) \"using\" constr(t) \"as\"\n  constr(s) :=\n  let u := fresh in\n    assert (u : t) by wp_power;\n  rewrite u in H;\n  clear u."
    },
    {
      "type": "code",
      "text": ""
    },
    {
      "type": "code",
      "text": ""
    },
    {
      "type": "code",
      "text": ""
    },
    {
      "type": "code",
      "text": ""
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "## **Applying one of the assumptions**\nDeprecate (?)"
    },
    {
      "type": "code",
      "text": "Tactic Notation \"This\" \"follows\" \"by\" \"assumption\" := \n  assumption."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "## **Claims**\nThe following tactics are variants of the ``assert`` tactic.\nEnables the user to prove a 'sublemma' in a proof.\\\n**TODO**\n- Is this a suitable notation?\n- Consider tactic ``We claim by _ that _``\n- (Automatically) naming the claim"
    },
    {
      "type": "code",
      "text": "Tactic Notation \"We\" \"claim\" \"that\" constr(t) \"(\" ident(u) \")\" :=\n  assert (u : t)."
    },
    {
      "type": "text",
      "text": "## **Rewriting**\n\nThe following tactics are variants on the ``rewrite`` tactic.\\\n**TODO**\n- Allow for multiple rewrites simultaneously using keywords such as `as, in, with ..`"
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Rewrite\" \"using\" constr(t) :=\n  let u := fresh in\n    assert (u : t) by wp_power;\n  rewrite u;\n  clear u.\n\nTactic Notation \"rewrite\" \"using\" constr(t) :=\n  let u := fresh in\n    assert (u : t) by wp_power;\n  rewrite u;\n  clear u.\n\nTactic Notation \"Rewrite\" \"using\" constr(t) \"in\" ident(s):=\n  let u := fresh in\n    assert (u : t) by wp_power;\n  rewrite u in s;\n  clear u.\n\nTactic Notation \"rewrite\" \"using\" constr(t) \"in\" ident(s):=\n  let u := fresh in\n    assert (u : t) by wp_power;\n  rewrite u in s;\n  clear u.\n\nTactic Notation \"Rewrite\" \"<-\" \"using\" constr(t) :=\n  let u := fresh in \n    assert (u : t) by wp_power;\n  rewrite<-u;\n  clear u."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "code",
      "text": "Tactic Notation \"replacing\" constr(s) \"with\" constr(t) :=\n  replace s with t by wp_power."
    },
    {
      "type": "text",
      "text": "## Applying lemmas and theorems"
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Apply\" uconstr(t) :=\n  apply t."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "Note: when using `constr(t)` instead of `uconstr(t)`, the use of wildcareds is no longer possible.\n\nTODO: add option to do an 'apply with'."
    },
    {
      "type": "text",
      "text": "## Expanding definitions\n\nTODO: add more options for these tactics."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Unfold\" constr(t) :=\n  unfold t.\n\nTactic Notation \"Unfold\" constr(t) \"in\" ident(s):=\n  unfold t in s.\n\nTactic Notation \"Expand\" \"the\" \"definition\" \"of\" reference(t) :=\n  unfold t.\n\nTactic Notation \"Expand\" \"the\" \"definition\" \"of\" \n  reference(t) \"in\" ident(s) :=\n  unfold t in s."
    },
    {
      "type": "code",
      "text": "\nTactic Notation \"Write\" ident(s) \"as\" constr(t) :=\n  change t in s."
    },
    {
      "type": "code",
      "text": ""
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "## Strings of (in)equalities\n\nThe following tactics should help in situations where in a pen-and-paper proof we would write a string equalities and inequalites.\n\n**Note:** As of now, forward reasoning by \"it holds that\" seems to be a better option.\n\nThe tactic `trans_ineq eq_or_ineq` reduces the inequality in the goal to a new one by using `eq_or_ineq`."
    },
    {
      "type": "code",
      "text": "Ltac trans_ineq eq_or_ineq := \n  match goal with \n  | [|-?x <= ?z] => \n    match (type of eq_or_ineq) with \n    | (x <= ?y) => apply (Rle_trans x y z eq_or_ineq)\n    | _ => idtac \"not a less-than-or-equal-to inequality\"\n    end\n  | _ => idtac \"Goal is not a less-than-or-equal-to inequality.\"\n  end."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "## Defining new variables"
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Define\" ident(u) \":=\" constr(t) :=\n  set (u := t)."
    },
    {
      "type": "text",
      "text": ""
    },
    {
      "type": "text",
      "text": "## Reflexivity"
    },
    {
      "type": "code",
      "text": "Tactic Notation \"This\" \"follows\" \"by\" \"reflexivity\" :=\n  reflexivity."
    },
    {
      "type": "text",
      "text": "## Simplification\n\nTODO: the following tactic notation may need to be improved."
    },
    {
      "type": "code",
      "text": "Tactic Notation \"Simplify\" \"what\" \"we\" \"need\" \"to\" \"show\" :=\n  simpl."
    },
    {
      "type": "text",
      "text": "## Hints"
    },
    {
      "type": "code",
      "text": "Hint Resolve Rmult_gt_0_compat : real.\nHint Resolve Rmult_lt_0_compat : real."
    }
  ]
}