{
  "exerciseSheet": false,
  "blocks": [
    {
      "type": "text",
      "text": "# **Definitions and Notations for Waterproof**"
    },
    {
      "type": "code",
      "text": "Require Import Reals.\nRequire Import Rbase.\nRequire Import Rfunctions.\nRequire Import SeqSeries.\nRequire Import Rtrigo.\nRequire Import Ranalysis.\nRequire Import Integration.\nRequire Import micromega.Lra.\nRequire Import Omega.\nRequire Import Max.\n\n"
    },
    {
      "type": "text",
      "text": "## Reals\n\n#### Quantifiers\nAllow unicode characters ∀ and ∃ for readability."
    },
    {
      "type": "code",
      "text": "Notation \"'for' 'all' x .. y , P\" := (forall x, .. (forall y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' for  all  x .. y ']' , '//'  P ']'\") : type_scope.\n\nNotation \"∀ x .. y , P\" := (forall x, .. (forall y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  only parsing) : type_scope.\n\nNotation \"'there' 'exists' x .. y , P \" := (exists x, .. (exists y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' there  exists  x .. y  ']' , '//'  P ']'\") : type_scope.\n\nNotation \"∃ x .. y , P \" := (exists x, .. (exists y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  only parsing) : type_scope.\n  \nNotation \"'fun' x .. y '↦' t\" := (fun x => .. (fun y => t) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' 'fun' x .. y ']' '↦' '/' t ']'\")."
    },
    {
      "type": "text",
      "text": "### Mathematical symbols"
    },
    {
      "type": "code",
      "text": "Notation \"x ∨ y\" := (x \\/ y) (at level 85, right associativity) : type_scope.\nNotation \"x ∧ y\" := (x /\\ y) (at level 80, right associativity) : type_scope.\nNotation \"x → y\" := (x -> y)\n  (at level 99, y at level 200, right associativity,\n   only parsing): type_scope.\nNotation \"x ⇒ y\" := (x -> y)\n  (at level 99, y at level 200, right associativity,\n   only parsing): type_scope.\n(* the notation below is fun, but is no good for functions *)\n(* need to see if this can be adapted so it only uses \n   this notation for propositions *)\n(*Notation \"'if' x 'then' y\" := (x -> y)\n  (at level 99, y at level 200, right associativity): prop_scope.*)\nNotation \"x ⇨ y\" := (x -> y)\n  (at level 99, y at level 200, right associativity): type_scope.\n\nNotation \"x ↔ y\" := (x <-> y) (at level 95, no associativity): type_scope.\nNotation \"x ⇔ y\" := (x <-> y) (at level 95, no associativity): type_scope.\nNotation \"¬ x\" := (~x) (at level 75, right associativity) : type_scope.\n(* TODO: the below definition doesn't work very nicely *)\nNotation \"x ↦ y\" := (fun x => y) (at level 0)."
    },
    {
      "type": "text",
      "text": "### (In)equalities"
    },
    {
      "type": "code",
      "text": "Notation \"x ≠ y\" := (x <> y) (at level 70) : type_scope.\n\nNotation \"x ≤ y\" := (le x y) (at level 70, no associativity) : nat_scope.\nNotation \"x ≥ y\" := (ge x y) (at level 70, no associativity) : nat_scope.\n\nNotation \"x ≤ y\" := (x <= y)%R (at level 70, no associativity) : R_scope.\nNotation \"x ≥ y\" := (x >= y)%R (at level 70, no associativity) : R_scope."
    },
    {
      "type": "text",
      "text": "### Scope, set notation and extending hint base"
    },
    {
      "type": "code",
      "text": "Open Scope nat_scope.\nOpen Scope R_scope.\n\n(* TODO: the below definition doesn't work very nicely *)\nNotation \"x ↦ y\" := (fun x => y) (at level 0).\n\nNotation \"'ℕ'\" := (nat).\nNotation \"'ℝ'\" := (R).\n\n(** We use coercions to get around writing INR and IZR *)\nCoercion INR: nat >-> R.\nCoercion IZR: Z >-> R.\n\n(** Add field and lra to tactics to try automatically *)\nHint Extern 3 ( _ = _ ) => field : real.\nHint Extern 3 ( _ <= _ ) => lra : real.\nHint Extern 3 ( _ >= _ ) => lra : real.\nHint Extern 3 ( _ < _ ) => lra : real.\nHint Extern 3 ( _ > _ ) => lra : real."
    },
    {
      "type": "text",
      "text": "## Sequences"
    },
    {
      "type": "code",
      "text": "Definition converges_to (a : ℕ → ℝ) (c : ℝ) :=\n  ∀ ε : ℝ, ε > 0 ⇒ \n    ∃ N : ℕ, ∀ n : ℕ, (n ≥ N)%nat ⇒\n      R_dist (a n) c < ε.\n      \nNotation \"a ⟶ l\" := (converges_to a l) (at level 20)."
    },
    {
      "type": "text",
      "text": "## Real numbers\n\nWe have to take care with the associative leve.\nWhen using this in rewrites, $<$, $>$, etc. should bind stronger."
    },
    {
      "type": "code",
      "text": "Notation \"｜ x ｜\" := (Rabs x) (at level 69, x at level 200).\n Notation \"｜ x - y ｜\" := (R_dist x y) (at level 69, x at level 48, y at level 48)."
    },
    {
      "type": "text",
      "text": "## Suprema and infima"
    },
    {
      "type": "code",
      "text": "Notation is_sup := is_lub.\nNotation is_bdd_above := bound."
    },
    {
      "type": "text",
      "text": "## Sequences"
    },
    {
      "type": "code",
      "text": "(**Notation \"an 'converges' 'to' a\" := \n  (Un_cv an a) (at level 50).*) "
    },
    {
      "type": "text",
      "text": "## Sums and series"
    },
    {
      "type": "code",
      "text": "Notation \"'Σ' Cn 'equals' x\" := \n  (infinite_sum Cn x) (at level 50).\n  \n(*Notation \"'Σ' 'of' Cn 'up' 'to' n\" := \n  (sum_f_R0 Cn n) (at level 50). \n (*Sum and series also defined in series.wpn. What to adapt?*)*)"
    },
    {
      "type": "text",
      "text": "## Functions"
    },
    {
      "type": "text",
      "text": "For the composition of a sequence and a function (e.g. for the sequence of measures of a sequence of sets):"
    },
    {
      "type": "code",
      "text": "(*Notation \"μ ◦ C\" := \n  (fun (n:ℕ) ↦ (μ (C n))) (at level 45).*)"
    },
    {
      "type": "text",
      "text": "## Sets"
    },
    {
      "type": "code",
      "text": "Definition is_in {D : Set} := fun (A : (D → Prop)) ↦ (fun (x : D) ↦ A x).\nNotation \"x ∈ A\" := (@is_in _ A x) (at level 50) : analysis_scope."
    }
  ]
}