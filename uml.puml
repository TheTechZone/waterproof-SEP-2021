@startuml
class LocInfo extends CoqType {
    +fname: string
    +line_nb: number
    +bol_pos: number
    +line_nb_last: number
    +bol_pos_last: number
    +bp: number
    +ep: number
    +pprint(indent?: number): string
}
class CLambdaN extends CoqType {
    +localExprs: any
    +expr: { locinfo: LocInfo; content: any; }
    +pprint(indent?: number): string
}
class CLocalAssum extends CoqType {
    +names: any
    +binderKind: any
    +expr: { locinfo: LocInfo; content: any; }
    +pprint(indent?: number): string
}
class CNotation extends CoqType {
    +notation: CoqType
    +constrNotationSubstitution: { exprListOfLists: any; patternExprs: any; binderExprsListOfLists: any; exprList: any[]; }
    +pprint(indent?: number): string
}
class CoqAST extends CoqType implements Visitable {
    +locinfo: LocInfo
    +content: any
    +accept(visitor: ASTVisitor): void
    +pprint(indent?: number): string
}
class CPrim extends CoqType {
    +isNumeric: boolean
    +value: string | Record<string, unknown>
    +pprint(indent?: number): string
}
class CProdN extends CoqType {
    +localExprs: [CoqType]
    +expr: { locinfo: LocInfo; content: any; }
    +pprint(indent?: number): string
}
class CRef extends CoqType {
    +libNames: { locinfo: any; content: any; }
    +instanceExpr: any
    +pprint(indent?: number): string
}
class DefineBody extends CoqType {
    +localExprList: any
    +rawRedExprOption: any
    +expr: { locinfo: LocInfo; content: any; }
    +exprOption: any
    +pprint(indent?: number): string
}
class GenericVType extends CoqType implements Visitable {
    +attributes: { attrs: any; control: any; }
    +data: any
    +pprint(indent?: number): string
    +accept(visitor: ASTVisitor): void
}
class HintsResolve extends CoqType {
    +hintList: any
    +pprint(): string
}
class HintsReference extends CoqType {
    +locinfo: any
    +content: any
    +pprint(indent?: number): string
}
class IDt extends CoqType {
    +name: any
    +pprint(indent?: number): string
}
class InConstrEntry extends CoqType {
    +data: any
    +pprint(indent?: number): string
}
class SerQualid extends CoqType {
    +dirPath: any
    +id: any
    +pprint(indent?: number): string
}
enum DefinitionObjectKind {
    Definition
    Coercion
    SubClass
    CanonicalStructure
    Example
    Fixpoint
    CoFixpoint
    Scheme
    StructureComponent
    IdentityCoercion
    Instance
    Method
    Let
}
class VernacDefinition extends CoqType implements Visitable {
    +discharge: boolean
    +defintionObjectKind: DefinitionObjectKind
    +nameDecl: { name: {    locinfo: LocInfo;    content: any;}; options: any; }
    +defitionExpr: any
    +pprint(indent?: number): string
    +accept(visitor: ASTVisitor): void
}
class VernacExpr extends CoqType {
    +content: any
    +print(indent?: number): string
}
class VernacExtend extends CoqType implements Visitable {
    +data: any
    +pprint(indent?: number): string
    +accept(visitor: ASTVisitor): void
}
class VernacHints extends CoqType implements Visitable {
    +strings: any
    +hintExpr: any
    +pprint(indent?: number): string
    +accept(visitor: ASTVisitor): void
}
class VernacProof extends CoqType implements Visitable {
    +sectionSubsetExpr: any
    +rawGenericArg: any
    +pprint(indent?: number): string
    +accept(visitor: ASTVisitor): void
}
class VernacRequire extends CoqType implements Visitable {
    +qualid: any
    +export_flag: boolean
    +list: any
    +pprint(indent?: number): string
    +accept(visitor: ASTVisitor): void
}
enum TheoremKind {
    Theorem
    Lemma
    Fact
    Remark
    Property
    Proposition
    Corollary
}
class VernacStartTheoremProof extends CoqType implements Visitable {
    +theoremKind: TheoremKind
    +proofExprs: any[]
    +pprint(indent?: number): string
    +accept(visitor: ASTVisitor): void
}
interface ASTVisitor {
    +visitCoqAST(term: CoqAST): void
    +visitGenericVType(term: GenericVType): void
    +visitCoqType(term: CoqType): void
    +visitCApp(term: CApp): void
    +visitCLambdaN(term: CLambdaN): void
    +visitCLocalAssum(term: CLocalAssum): void
    +visitCNotation(term: CNotation): void
    +visitCoqAst(term: CoqAST): void
    +visitCPrim(term: CPrim): void
    +visitCProdN(term: CProdN): void
    +visitCRef(term: CRef): void
    +visitDefineBody(term: DefineBody): void
    +visitHintsResolve(term: HintsResolve): void
    +visitIDt(term: IDt): void
    +visitInConstrEntry(term: InConstrEntry): void
    +visitLocInfo(term: LocInfo): void
    +visitSerQualid(term: SerQualid): void
    +visitVernacDefinition(term: VernacDefinition): void
    +visitVernacEndProof(term: VernacEndProof): void
    +visitVernacExpr(term: VernacExpr): void
    +visitVernacExtend(term: VernacExtend): void
    +visitVernacHints(term: VernacHints): void
    +visitVernacProof(term: VernacProof): void
    +visitVernacRequire(term: VernacRequire): void
    +visitVernacStartTheoremProof(term: VernacStartTheoremProof): void
}
abstract class CoqType implements Visitable {
    +pprint(indent?: number): string
    +sprintf(format: any, args: any[]): string
    +cprint(content: any, indent: any): string
    +accept(visitor: ASTVisitor): void
}
interface Visitable {
    +accept(visitor: ASTVisitor): void
}
class VernacEndProof extends CoqType implements Visitable {
    +proofEnd: string
    +proofDetails: { isOpaque: boolean; lident: CoqType; }
    +proofFinished: boolean
    +pprint(indent?: number): string
    +accept(visitor: ASTVisitor): void
}
class CApp extends CoqType {
    +first: { projFlag: any; expr: {    locinfo: LocInfo;    content: any;}; }
    +pprint(indent?: number): string
}
@enduml